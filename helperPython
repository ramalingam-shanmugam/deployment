#!/usr/bin/python
###############################################################################
# Module Name   : QMHelper.py
# Dependencies  : none
# Description   : To deploy the latest queue manager and session manager war files in deployment servers
# Contact       : rasmi.nayak.up9m@statefarm.com
###############################################################################
import pprint,json
import ConfigParser
import logging
import logging.handlers
import subprocess
from subprocess import Popen, PIPE
from xml.dom import minidom
import urllib2;
import os.path

## global variables
SERVER_TYPE_QM="QueueManager";
SERVER_TYPE_SM="SessionManager";
SERVER_TYPE_UB="UrlBuilder";
QM_DEPLOYMENT_CONFIG="qmDeploymentServers.cfg";
QM_DEPLOYMENT_PLAN="qmDeploymentServers.json";
LOG=""
#------------------------------------------------------------------------------
# Function: parse_deployment_config
# Returns : object
# input   :  QM_DEPLOYMENT_CONFIG file
#------------------------------------------------------------------------------

def parse_deployment_plan_config(config_file):
    try:
        file_handler=open(config_file,"r")
        json_data=json.load(file_handler);
        file_handler.close();
        return json_data;
    except IOError:
        print( "Error: can\'t find file or read data, file name is %s "%QM_DEPLOYMENT_CONFIG )
    except :
         print ("Error:while parsing the deployment plan configuration file %s " %config_file)

#------------------------------------------------------------------------------
# Function: parse_environment_config
# Returns : value
# input   :  QM_DEPLOYMENT_CONFIG file and attribute
#------------------------------------------------------------------------------

def parse_environment_config(config_file,attribute):
    config_section="qm";
    try:
        config = ConfigParser.ConfigParser();
        config.read(config_file);
        value=config.get(config_section, attribute);
        #LOG.info ("Attribute value is : %s" %value);
        return value;
    except:
        print ("Error:while parsing the environment configuration file %s , may be attribute %s does n\'t exists" % (config_file , attribute))
 
def logging_setup (logger_name,file_name,stdout_flag=False):
    log = logging.getLogger(logger_name);
    log.setLevel(logging.INFO);

    # create formatter and add it to the handlers
    formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s');
    app_log_file_size=parse_environment_config(QM_DEPLOYMENT_CONFIG,'APP_LOG_FILE_SIZE');
    app_log_file_backup_count=parse_environment_config(QM_DEPLOYMENT_CONFIG,'APP_LOG_FILE_BACKUP_COUNT');
    # create file handler which logs even debug messages
    if file_name != " ":
        fh = logging.FileHandler(file_name)
        logging.handlers.RotatingFileHandler(file_name, maxBytes=(app_log_file_size), backupCount=app_log_file_backup_count)
        fh.setLevel(logging.INFO)
        fh.setFormatter(formatter)
        log.addHandler(fh)
    if file_name != " " or stdout_flag == True:
        # create console handler with a higher log level
        ch = logging.StreamHandler()
        ch.setLevel(logging.INFO)
        ch.setFormatter(formatter)
        log.addHandler(ch)

    return log 
## I don't like this
LOG=logging_setup(__name__,__name__+".log",True);
#------------------------------------------------------------------------------
# Function: restart_tomcat_service
# Returns : one
# input   :  server_name
#------------------------------------------------------------------------------
def restart_tomcat_service(server_name):
    restart_flag=0;
    tomcat_restart_command="sudo service wt-tomcat8-tomcat_1 restart";
    try:
        sshProcess = Popen(['ssh', '-q', server_name,tomcat_restart_command],stdin=PIPE,stdout = PIPE);
        sshProcess.wait(30);
            
        for line in  sshProcess.stdout:
            if line.strip() == "Tomcat started.":
                LOG.info ("Restarting tomcat server "+ server_name+" successfully...");
                restart_flag=1;

    except subprocess.TimeoutExpired:
        LOG.error("command ("+server_name+") time-out after 30 sec tomcat on server "+ tomcat_restart_command);
    except:
        LOG.error("Unknow Error while restarting tomcat on server " +server_name);
    
    return restart_flag;

#------------------------------------------------------------------------------
# Function: control_tomcat_service
# Returns : 1/0
# input   :  server_name ,action
# example : control_tomcat_service("cc95tc00000000g.opr.test.statefarm.org","start")
#------------------------------------------------------------------------------
def control_tomcat_service(server_name,action):
    control_flag=0;
    tomcat_restart_command="sudo service wt-tomcat8-tomcat_1 ";
    line_match= "Stoping Tomcat" if action == "stop" else "Starting tomcat";

    try:
        sshProcess = Popen(['ssh', '-q', server_name,tomcat_restart_command,action],stdin=PIPE,stdout = PIPE);
        sshProcess.wait(30);
            
        for line in  sshProcess.stdout:
            if line.strip() == line_match:
                LOG.info (action+"ed tomcat server "+ server_name+" successfully...");
                control_flag=1;

    except subprocess.TimeoutExpired:
        LOG.error("command ("+server_name+") time-out after 30 sec tomcat on server "+ tomcat_restart_command + action);
    except:
        LOG.error("Unknow Error while "+action+" tomcat on server " +server_name);
    
    return control_flag;

#------------------------------------------------------------------------------
# Function: control_apache_service
# Returns : 1/0
# input   :  server_name ,action
# example : control_apache_service("cc95tc00000000g.opr.test.statefarm.org","start")
#------------------------------------------------------------------------------
def control_apache_service(server_name,action):
    control_flag=0;
    apache_restart_command="sudo service wtapache ";
    line_match="httpd:"
    try:
        sshProcess = Popen(['ssh', '-q', server_name,apache_restart_command,action],stdin=PIPE,stdout = PIPE);
        sshProcess.wait(30);
            
        for line in  sshProcess.stdout:
            if line_match in line.split():
                LOG.info (action+"ed apache server "+ server_name+" successfully...");
                control_flag=1;

    except subprocess.TimeoutExpired:
        LOG.error("command ("+server_name+") time-out after 30 sec tomcat on server "+ apache_restart_command + action);
    except:
        LOG.error("Unknow Error while "+action+" apache on server " +server_name);
    
    return control_flag;	
	
#------------------------------------------------------------------------------
# Function: restart_tomcat_service
# Returns : none
# input   :  server_name
#------------------------------------------------------------------------------

def deploy_app_remote_server(server_name,server_type,source_war_file_name,destination_war_file_name):
    
    local_war_file_path=parse_environment_config(QM_DEPLOYMENT_CONFIG,'WAR_FILE_PATH');
    war_file_extension=parse_environment_config(QM_DEPLOYMENT_CONFIG,'WAR_FILE_EXTENSION');
    
    #source_war_file_name=str(source_war_file_name)+war_file_extension;
    source_war_file_name=str(source_war_file_name);
    destination_war_file_name=destination_war_file_name+war_file_extension;
    
    LOG.info( "Source war file name is "+source_war_file_name +" Destination war file name "+destination_war_file_name);
    
    if not os.path.exists(local_war_file_path+source_war_file_name):
        LOG.error (" Source war file "+source_war_file_name+" doesn't exists  in  " +local_war_file_path);
        return 0;
        
    if  source_war_file_name != "" and  destination_war_file_name !="" :
        deplyable_file_path=parse_environment_config(QM_DEPLOYMENT_CONFIG,'APP_BASE_DIR_PATH') or "/tmp/";
        rValScpRemoteFile=_scp_remote_file(source_war_file_name,destination_war_file_name, server_name,deplyable_file_path,local_war_file_path);
        LOG.info ("Return value after scp war file "+source_war_file_name+" to remote server "+server_name+" is "+str(rValScpRemoteFile));
        if rValScpRemoteFile == 1:
            LOG.info("File uploaded successfully to server " + server_name);
            return 1;
        else:
            LOG.error("File upload failed.");
    else:
        return 0;

	
#------------------------------------------------------------------------------
# Function: update_environmentfile_remote_server
# Returns : 1 or 0
# input   :  server_name, environmentData
#------------------------------------------------------------------------------

def update_environmentfile_remote_server(server_name,environmentData):
    source_script_file_name = "updatesetenvfile.py";
    
    #source_war_file_name=str(source_war_file_name)+war_file_extension;
    
    LOG.info( "Source war file name is "+source_war_file_name +" Destination war file name "+destination_war_file_name);
    
    if not os.path.exists(source_env_file_name):
        LOG.error ("Source Environment file "+ source_env_file_name +" doesn't exists");
        return 0;
        
	rValScpRemoteFile=_scp_remote_scriptfile(source_script_file_name, server_name);
	LOG.info ("Return value after scp script file "+ source_script_file_name +" to remote server "+ server_name + " is " + str(rValScpRemoteFile));
	if rValScpRemoteFile == 1:
		LOG.info("Script file uploaded successfully to server " + server_name);
		#Set the execute permission to the uploaded script file
		
		return 1;
	else:
		LOG.error("Script file upload failed.");
        
        
#------------------------------------------------------------------------------
# Function: _scp_remote_file
# Returns : success = 1, failure= 0
# input   :  file_name, remote_path, remote_path
# Type    :  private
#------------------------------------------------------------------------------
def _scp_remote_file(source_war_file_name,destination_war_file_name, remote_server_name, remote_path ,local_war_file_path):
    returnVal=0;
    user_remote_server_name_path="wbtchadm@"+remote_server_name+":"+remote_path+"/"+destination_war_file_name;
    local_war_file=local_war_file_path+"/"+source_war_file_name;
    remote_copy_command=" ".join(["/usr/bin/scp", local_war_file,user_remote_server_name_path]);
    localhost=_localhostname();
    try:
        LOG.info ("Copying war file("+local_war_file+")from source server "+localhost+" to destination server "+user_remote_server_name_path);
        sshProcess = Popen(['/usr/bin/scp' ,'-q', local_war_file , user_remote_server_name_path],stdin=PIPE,stdout = PIPE);
        sshProcess.wait(120);
        returnVal=1;
    except:
        LOG.error ("command "+remote_copy_command+" errored out tomcat on server " +remote_server_name);
        returnVal=0;

    return returnVal;

#------------------------------------------------------------------------------
# Function: _scp_remote_environmentfile
# Returns : success = 1, failure= 0
# input   :  file_name, remote_path, remote_path
# Type    :  private
#------------------------------------------------------------------------------
def _scp_remote_scriptfile(source_script_file_name, remote_server_name):
    returnVal=0;
    user_remote_server_name_path="wbtchadm@"+remote_server_name+":/tmp";

	#scp updatesetenvfile.py wbtchadm@cc95tc00000000f.opr.test.statefarm.org:/tmp
    remote_copy_command=" ".join(["/usr/bin/scp", "-q", source_script_file_name, user_remote_server_name_path]);
    localhost=_localhostname();
    try:
        LOG.info ("Copying environment file("+local_war_file+")from source server "+localhost+" to destination server "+user_remote_server_name_path);
        sshProcess = Popen(['/usr/bin/scp' ,'-q', source_script_file_name , user_remote_server_name_path],stdin=PIPE,stdout = PIPE);
        sshProcess.wait(120);
        returnVal=1;
    except:
        LOG.error ("command "+remote_copy_command+" errored out tomcat on server " +remote_server_name);
        returnVal=0;

    return returnVal;
	
#------------------------------------------------------------------------------
# Function: _get_warfilename_from_serverType
# Returns : File_name
# input   :  server_type
# Type    :  private
#------------------------------------------------------------------------------

def _get_warfilename_from_serverType(server_type,rc_tag):
    source_war_file_name="" 
    destination_war_file_name=""
    
    war_file_path=parse_environment_config(QM_DEPLOYMENT_CONFIG,'WAR_FILE_PATH');
    war_file_extension=parse_environment_config(QM_DEPLOYMENT_CONFIG,'WAR_FILE_EXTENSION');
    LOG.info("War file path "+war_file_path + " war_file_extension "+war_file_extension);
    
    if server_type == SERVER_TYPE_QM :
        file_name=parse_environment_config(QM_DEPLOYMENT_CONFIG,'QM_WAR_NAME');
        source_war_file_name=file_name+"-"+rc_tag["qmanager_rc_version"]+war_file_extension;
        destination_war_file_name=file_name+war_file_extension;
        LOG.info("destination_war_file_name "+destination_war_file_name);
    elif server_type == SERVER_TYPE_SM:
        source_war_file_name=file_name+"-"+rc_tag["sessionmanager_rc_version"]+war_file_extension;
        destination_war_file_name=file_name+war_file_extension;
        LOG.info("destination_war_file_name "+destination_war_file_name);
    elif server_type == SERVER_TYPE_UB:
        source_war_file_name=file_name+"-"+rc_tag["urlbuilder_rc_version"]+war_file_extension;
        destination_war_file_name=file_name+war_file_extension;
        LOG.info("destination_war_file_name "+destination_war_file_name);
        
    return "/".join([war_file_path,source_war_file_name]),"/".join([war_file_path,destination_war_file_name]);


#------------------------------------------------------------------------------
# Function: _localhostname
# Returns : local host name
# input   :  none
# Type    :  private
#------------------------------------------------------------------------------
    

def _localhostname():
    LOG.info(" localhost name "+os.uname()[1]);
    return os.uname()[1];

#------------------------------------------------------------------------------
# Function: _localhostname
# Returns : local host name
# input   :  none
# Type    :  private
#------------------------------------------------------------------------------
 
def update_status_config(server_name,value_type,value):
    LOG.info("Updating server name" +server_name+ " Server Type "+value_type+ " Value is "+str(value));
    with open(QM_DEPLOYMENT_PLAN) as data_file:
        data = json.load(data_file)
        for jsonArrayObj in data['servers']:
            if jsonArrayObj['name'] == server_name:
                if value_type == "status":
                    jsonArrayObj['status'] = value;
                if  value_type == "version":
                    jsonArrayObj['version'] = value;
    with open(QM_DEPLOYMENT_PLAN, 'w') as data_file:
        json.dump(data, data_file)
    data_file.close()
    LOG.info("Updated successfully application deployment plan config file");

#------------------------------------------------------------------------------
# Function: _localhostname
# Returns : local host name
# input   :  none
# Type    :  private
#------------------------------------------------------------------------------

def validate_inputs_params(war_files):
    app_types=[];
    app_type_warfiles={}
    
    qm_deploment_json=parse_deployment_plan_config(QM_DEPLOYMENT_PLAN);
    
    for serverArrayObj in qm_deploment_json["servers"]:
        app_types.append(serverArrayObj["type"]);
    
    for app_type in set(app_types):
        for  war_file in (war_files):
            LOG.info("Validating war file name "+war_file +" with app name "+app_type);
            if  war_file.find(app_type) != -1:
                app_type_warfiles[str(app_type)]=war_file;

    if len(app_type_warfiles) == 0:
        LOG.error("Validation failed for war files "+str(war_files) +" , Please verify the naming in deployment plan config or war file name");
        return 0;
    else:
        LOG.info("Successfully validate the war files "+str(war_files) + str(app_type_warfiles));
        return app_type_warfiles;
        
 
def test_sshkey_remote_server(serverName):
    sshStatusFlag=0;
    sshCommand="uname -a";
    try:
        sshProcess = Popen(['ssh', '-q', serverName,sshCommand],stdin=PIPE,stdout = PIPE);
        sshProcess.wait(3);
        for line in  sshProcess.stdout:
            if  "Linux" in line:
                LOG.info ("SSH key verified successfully for server name "+ serverName);
                sshStatusFlag=1;

    except subprocess.TimeoutExpired:
        LOG.error("command ("+sshCommand+") time-out after 30 sec tomcat on server "+ sshCommand);
    except:
        LOG.error("testSSHKey - An exception occurred testing SSH key " +serverName);
    
    return sshStatusFlag;    

def _is_remote_file_exists(server_name,file_name,type):
    return_status=0;
    if server_name== "" or file_name == "":
        return return_status;
    
    command_test_file = "test "+type +" "+file_name+" && echo 'Yes' || echo 'No'"
    print "Command is ",command_test_file;
    try:    
        sshProcess = Popen(['ssh', '-q', server_name, command_test_file],stdin=PIPE,stdout = PIPE);
        sshProcess.wait(30);
        for line in  sshProcess.stdout:
            if line.strip() == "Yes":
                return_status = 1;
    except subprocess.TimeoutExpired:
        return_status = 0;
        
    return return_status;
         
def undeploy_app_remote_server(server_name, app_name):
    return_status = 0;
    app_count=0;
    if server_name== "" or app_name == "":
        return return_status;
    
    deplyable_file_path=parse_environment_config(QM_DEPLOYMENT_CONFIG,'APP_BASE_DIR_PATH') or "/tmp/";
    war_file_extension=parse_environment_config(QM_DEPLOYMENT_CONFIG,'WAR_FILE_EXTENSION');
    
    abbsolute_remote_app_name=deplyable_file_path+app_name;
    abbsolute_remote_war_name=abbsolute_remote_app_name+war_file_extension;
    
    type=" -d ";
    for app_name in [abbsolute_remote_app_name,abbsolute_remote_war_name]:
        if app_name.find(".war")  != -1:
            type=" -f ";
        if _is_remote_file_exists(server_name,app_name,type):
            try:
                remove_command="rm -rf  "+app_name;
                print "Removing ",remove_command;
                sshProcess = Popen(['ssh', '-q', server_name, remove_command],stdin=PIPE,stdout = PIPE);
                sshProcess.wait(30);
                app_count=app_count+1;
            except subprocess.TimeoutExpired:
                LOG.error("undeploy_app_remote_server - SSH session time-out while un-deploying app "+app_name +" on server name " +serverName);
                return_status=0;
            except:
                return_status=0;
                LOG.error("undeploy_app_remote_server - An exception occurred undeploy app " +app_name +" Server Name "+server_name);
    if app_count == 2:
        if restart_tomcat_service(server_name) == 1 :
            return 1;
    return return_status;
       
        
        
def get_sessionManager_config(sessionManagerUrl):
    data=urllib2.urlopen(sessionManagerUrl);
    doc = minidom.parse(data);
    nodelist = doc.getElementsByTagName("SessionManagerMapping");
    result = {}
    for node in nodelist:
        icsServerName=node.getElementsByTagName("icsServerName")[0].firstChild.data;
        peripheralID=node.getElementsByTagName("peripheralID")[0].firstChild.data;
        instanceName=node.getElementsByTagName("instanceName")[0].firstChild.data;
        result[str(icsServerName)]=str(instanceName+"::"+peripheralID);
        #print node;
    return result;        
